import _ from 'lodash';
import {expect, assert} from 'chai';
import * as optionParser from './optionParser';
import testData from './testData/optionParserTestData.json';
import productionSampleVariations from './testData/productionVariationOptionsSample.json';
import productionSamplesWithRecipientEnum from './testData/productionOptions.json';
import * as propertySets from './data/propertySets';

const RECIPIENTS = {
  BABIES: 266817085,
  WOMEN: 266817061,
  GIRLS: 266817077,
  BABY_GIRLS: 266817083
};

const SCALES = {
  ALPHA: 301,
  US_WOMEN: 310,
  POUNDS: 332,
  HEIGHT_CM: 348,
  EU_GIRLS: 385,
  OTHER_SIZE: 329,
  MONTHS: 303
};

describe('optionParser', () => {
  it('can strip the price off a formatted string', () => {
    expect(optionParser.stripPrice('hello [US$20]', 'hello')).to.equal('hello');
    expect(optionParser.stripPrice('US 12 [US$20]', '12')).to.equal('US 12');
  });

  it('does not strip the price when the price is just a part of the name', () => {
    const optionValue = 'this is just [a funny name]';
    expect(optionParser.stripPrice(optionValue, optionValue)).to.equal(optionValue);
  });

  it('Can strip away a recipient string and resolve the recipient ID', () => {
    const result = optionParser.stripRecipient('US 12 - Women', '12');
    expect(result).to.have.property('formattedValue', 'US 12');
    expect(result).to.have.property('recipientId', RECIPIENTS.WOMEN);
  });

  it('Does not strip away something that looks like a recipient but is part of the actual description', () => {
    const strangeDescription = 'Happy - Women';
    const result = optionParser.stripRecipient(strangeDescription, strangeDescription);
    expect(result).to.have.property('formattedValue', strangeDescription);
    expect(result).to.have.property('recipientId', null);
  });


  it('Can parse the recipient and scaleId from a formatted option string that has prefix and suffix', () => {
    const result = optionParser.resolveByFormattedValue(1429, 100, 'US 6 - Women', '6');
    expect(result).to.have.property('recipientId', RECIPIENTS.WOMEN);
    expect(result).to.have.property('scaleId', SCALES.US_WOMEN);
  });

  // this set of tests uses data generated by configuring listings on etsy
  // and looking at the payloads returned
  describe('Etsy-returned data tests', () => {
    const resolveByFormattedValue = (sampleData, option) => optionParser.resolveByFormattedValue(sampleData.taxonomyId, sampleData.propertyId, option.formattedValue, option.value);
    const resolveScaleByOptionId = (sampleData, recipientId, optionId) => optionParser.resolveScaleByOptionId(sampleData.taxonomyId, sampleData.propertyId, recipientId, optionId);

    describe('Resolving options by formatted values', () => {
      const testAllOptions = (sampleData, expectedResult) => {
        _.forEach(sampleData.options, (option) => {
          expect(resolveByFormattedValue(sampleData, option)).to.eql(expectedResult);
        });
      };

      it('Can determine the right qualifiers for some straightforward option sets', () => {
        testAllOptions(testData.weightInPounds, { recipientId: null, scaleId: SCALES.POUNDS });
        testAllOptions(testData.heightWithPrices, { recipientId: null, scaleId: SCALES.HEIGHT_CM });
        testAllOptions(testData.sizeWithRecipientAndPrices, { recipientId: RECIPIENTS.GIRLS, scaleId: SCALES.EU_GIRLS });
        testAllOptions(testData.noQualifiers, { recipientId: null, scaleId: null });
        testAllOptions(testData.alphaSizeWithRecipient, { recipientId: RECIPIENTS.GIRLS, scaleId: SCALES.ALPHA });
      });

      it('Determines the possible options of "Alpha" and "Other" when both are possible', () => {
        const data = testData.alphaSizeWithoutRecipient;
        const result = resolveByFormattedValue(data, data.options[0]);
        expect(result.recipientId).to.be.null;
        expect(result.scaleId).to.be.null;
        expect(result.possibleScaleIds).to.be.an('array').and.have.all.members([SCALES.OTHER_SIZE, SCALES.ALPHA]);
      });

      it('Determines the possible options of "Alpha" and "Months" when both are possible', () => {
        const data = testData.babiesRecipientMonthsSizing;
        const result = resolveByFormattedValue(data, data.options[0]);
        expect(result.recipientId).to.equal(RECIPIENTS.BABIES);
        expect(result.scaleId).to.be.null;
        expect(result.possibleScaleIds).to.be.an('array').and.have.all.members([SCALES.ALPHA, SCALES.MONTHS]);
      });
    });

    describe('Resolving options by valueId', () => {
      it('Detects "Alpha" vs "Other" by option Ids when either might work by formatted string', () => {
        const data = testData.alphaSizeWithoutRecipient;
        const result = resolveByFormattedValue(data, data.options[0]);
        expect(result.recipientId).to.be.null;
        expect(result.scaleId).to.be.null;
        expect(result.possibleScaleIds).to.be.an('array').and.have.all.members([SCALES.OTHER_SIZE, SCALES.ALPHA]);
        const optionId = data.options[0].valueId;
        const betterResult = resolveScaleByOptionId(data, null, optionId);
        expect(betterResult).to.be.an('array').and.have.length(1);
        expect(betterResult[0]).to.equal(SCALES.ALPHA);
      });

      it('Detects "Months" vs "Alpha" by optionIds Ids when either might work by formatted string', () => {
        const data = testData.babiesRecipientMonthsSizing;
        const result = resolveByFormattedValue(data, data.options[0]);
        expect(result.recipientId).to.equal(RECIPIENTS.BABIES);
        expect(result.scaleId).to.be.null;
        expect(result.possibleScaleIds).to.be.an('array').and.have.all.members([SCALES.ALPHA, SCALES.MONTHS]);
        const optionId = data.options[0].valueId;
        const betterResult = resolveScaleByOptionId(data, RECIPIENTS.BABIES, optionId);
        expect(betterResult).to.be.an('array').and.have.length(1);
        expect(betterResult[0]).to.equal(SCALES.MONTHS);
      });

      it('Still cannot figure out what to do when non-suggested options are used', () => {
        const data = testData.babiesRecipientCustomMonthsSizing;
        const result = resolveByFormattedValue(data, data.options[0]);
        expect(result.recipientId).to.equal(RECIPIENTS.BABIES);
        expect(result.scaleId).to.be.null;
        expect(result.possibleScaleIds).to.be.an('array').and.have.all.members([SCALES.ALPHA, SCALES.MONTHS]);
        const optionId = data.options[0].valueId;
        const matchedOptionIds = resolveScaleByOptionId(data, RECIPIENTS.BABIES, optionId);
        expect(matchedOptionIds).to.be.an('array').and.have.length(0);
      });
    });

    describe('Resolving option lists', () => {
      const test = (data, expectedResult) => {
        const result = optionParser.resolveQualifiersForOptionList(data.taxonomyId, data.propertyId, data.options, data.recipient);
        expect(result).to.eql(expectedResult);
      };

      it('Can resolve qualifiers from a list of options that can be resolved by formatted string', () => {
        test(testData.weightInPounds, { recipientId: null, scaleId: SCALES.POUNDS });
        test(testData.heightWithPrices, { recipientId: null, scaleId: SCALES.HEIGHT_CM });
        test(testData.sizeWithRecipientAndPrices, { recipientId: RECIPIENTS.GIRLS, scaleId: SCALES.EU_GIRLS });
        test(testData.noQualifiers, { recipientId: null, scaleId: null });
        test(testData.alphaSizeWithRecipient, { recipientId: RECIPIENTS.GIRLS, scaleId: SCALES.ALPHA });
      });

      it('Can resolve qualifiers from a list of options that are known suggested options', () => {
        test(testData.alphaSizeWithoutRecipient, { recipientId: null, scaleId: SCALES.ALPHA });
        test(testData.babiesRecipientMonthsSizing, { recipientId: RECIPIENTS.BABIES, scaleId: SCALES.MONTHS });
      });

      it('Can resolve qualifiers if only one option is resolvable by option Id', () => {
        const data = testData.babiesRecipientMixSuggestedAndCustomSizing;

        // first let's show that only one of the three options is resolvable
        expect(data.options).to.have.length(3);
        let soloResolvableOptions = 0;
        _.forEach(data.options, (option) => {
          if (resolveByFormattedValue(data, option).scaleId) {
            soloResolvableOptions++;
          } else {
            const soloResult = resolveScaleByOptionId(data, RECIPIENTS.BABIES, option.valueId);
            if (soloResult.length === 1) {
              soloResolvableOptions++;
            }
          }
        });
        expect(soloResolvableOptions).to.equal(1);

        // but this one result can be used to resolve the whole set:
        test(data, { recipientId: RECIPIENTS.BABIES, scaleId: SCALES.MONTHS });
      });

      it('Can resolve qualifiers if only one option is resolvable by option Id and recipient is aliased', () => {
        const data = testData.babyGirlsRecipientMixSuggestedAndCustomSizing;

        // first let's show that only one of the three options is resolvable
        expect(data.options).to.have.length(3);
        let soloResolvableOptions = 0;
        _.forEach(data.options, (option) => {
          if (resolveByFormattedValue(data, option).scaleId) {
            soloResolvableOptions++;
          } else {
            const soloResult = resolveScaleByOptionId(data, RECIPIENTS.BABY_GIRLS, option.valueId);
            if (soloResult.length === 1) {
              soloResolvableOptions++;
            }
          }
        });
        expect(soloResolvableOptions).to.equal(1);

        // but this one result can be used to resolve the whole set:
        test(data, { recipientId: RECIPIENTS.BABY_GIRLS, scaleId: SCALES.MONTHS });
      });

      it('Picks Other over Alpha if both are valid', () => {
        const data = testData.noRecipientCustomOtherSizes;
        test(data, {recipientId: null, scaleId: SCALES.OTHER_SIZE });
      });

      it('Handles a specific value that failed for Tomas C', () => {
        optionParser.resolveQualifiersForOptionList(2198, 100,
          [{valueId: 1166388122, value: 'L', formattedValue: 'L - Teens'}]
        );
      });

      it('Can handle a sampling of variations pulled from production', () => {
        _.forEach(productionSampleVariations, (sampleRow) => {
          const propertyId = sampleRow.propertyId;
          const taxonomyId = sampleRow.taxonomyId;
          const options = [{
            value: sampleRow.value,
            valueId: sampleRow.valueId,
            formattedValue: sampleRow.formattedValue
          }];

          const requiresScale = !!propertySets.getFirstTierQualifier(taxonomyId, propertyId);
          const requiresRecipient = propertySets.requiresRecipient(taxonomyId, propertyId);

          const result = optionParser.resolveQualifiersForOptionList(taxonomyId, propertyId, options);
          if (requiresScale) {
            expect(result.scaleId).to.exist;
          } else {
            expect(result.scaleId).to.be.null;
          }

          if (requiresRecipient) {
            expect(result.recipientId).to.exist;
          } else {
            expect(result.recipientId).to.be.null;
          }
        });
      });

      it('Can handle hats and caps for babies by passing in the recipient enum value', () => {
        const data = testData.troubleWithHatsAndCapsForBabies;
        const result = optionParser.resolveQualifiersForOptionList(data.taxonomyId, data.propertyId, data.options, 'babies');
        expect(result).to.eql({ recipientId: RECIPIENTS.BABIES, scaleId: SCALES.MONTHS });
      });

      const makeAssertString = (val) => val ? 'non-null' : 'null';
      it('Can handle options for production using the recipient enum', function testcase() {
        this.timeout(0);
        _.forEach(productionSamplesWithRecipientEnum, (sampleRow) => {
          const propertyId = sampleRow.propertyId;
          const taxonomyId = sampleRow.taxonomyId;
          const options = [{
            value: sampleRow.value,
            valueId: sampleRow.valueId,
            formattedValue: sampleRow.formattedValue
          }];
          const recipient = sampleRow.recipient;

          const requiresScale = propertySets.requiresScale(taxonomyId, propertyId);
          const requiresRecipient = propertySets.requiresRecipient(taxonomyId, propertyId);

          const result = optionParser.resolveQualifiersForOptionList(taxonomyId, propertyId, options, recipient);

          if (requiresScale === !result.scaleId) {
            assert.fail(makeAssertString(result.scaleId), makeAssertString(requiresScale), 'Scale not resolved for ' + sampleRow.formattedValue);
          }

          if (requiresRecipient === !result.recipientId) {
            assert.fail(makeAssertString(result.recipientId), makeAssertString(requiresRecipient), 'Recipient not resolved for ' + sampleRow.formattedValue);
          }
        });
      });
    });
  });
});
